%%%-------------------------------------------------------------------
%%% @author neerajsharma
%%% @copyright (C) 2018, Neeraj Sharma
%%% @doc
%%%
%%% @end
%%% %CopyrightBegin%
%%%
%%% Copyright Neeraj Sharma <neeraj.sharma@alumni.iitg.ernet.in> 2017.
%%% All Rights Reserved.
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-------------------------------------------------------------------
-module(egraph_fquery_model).
%% -behaviour(egraph_callback).
-export([init/0, init/2, terminate/1, % CRUD
         validate/2, create/3, read/2, update/3, delete/2]).
-export([create/4, update/4]).
-export_type([egraph_k/0]).

-include("egraph_constants.hrl").

-type egraph_k() :: map().
-type state() :: term().

-define(LAGER_ATTRS, [{type, model}]).

%%%===================================================================
%%% API
%%%===================================================================

%%%===================================================================
%%% Callbacks
%%%===================================================================

%% @doc Initialize the state that the handler will carry for
%% a specific request throughout its progression. The state
%% is then passed on to each subsequent call to this model.
-spec init() -> state().
init() ->
    nostate.

init(_, QsProplist) ->
    [{proplist, QsProplist}].

%% @doc At the end of a request, the state is passed back in
%% to allow for clean up.
-spec terminate(state()) -> term().
terminate(_State) ->
    ok.

%% @doc Return, via a boolean value, whether the user-submitted
%% data structure is considered to be valid by this model's standard.
-spec validate(egraph_k() | term(), state()) -> {boolean(), state()}.
validate(V, State) ->
    {is_map(V), State}.

%% @doc Create a new entry. If the id is `undefined', the user
%% has not submitted an id under which to store the resource:
%% the id needs to be generated by the model, and (if successful),
%% returned via `{true, GeneratedId}'.
%% Otherwise, a given id will be passed, and a simple `true' or
%% `false' value may be returned to confirm the results.
%%
%% The created resource is validated before this function is called.
-spec create(egraph_callback:id() | undefined, egraph_k(), state()) ->
        {false | true | {true, egraph_callback:id()}, state()}.
create(undefined, V, State) ->
    create_or_update_info(V, State);
create(Key, V, State) ->
    Info2 = V#{<<"name">> => Key},
    create_or_update_info(Info2, State).

%% @doc Create a new entry along with an expiry of some seconds.
-spec create(egraph_callback:id() | undefined, egraph_k(),
             [{binary(), binary()}], state()) ->
    {false | true | {true, egraph_callback:id()}, state()}.
create(Key, V, _QsProplist, State) ->
    create(Key, V, State).

%% @doc Read a given entry from the store based on its Key.
-spec read(egraph_callback:id(), state()) ->
        { {ok, egraph_k()} |
          {function, Fun :: function()},
          {error, not_found}, state()}.
read(_Key, State) ->
    {{error, not_fount}, State}.

%% @doc Update an existing resource.
%%
%% The modified resource is validated before this function is called.
-spec update(egraph_callback:id(), egraph_k(), state()) -> {boolean(), state()}.
update(Key, V, State) ->
    Info2 = V#{<<"name">> => Key},
    create_or_update_info(Info2, State).

%% @doc Update an existing resource with some expiry seconds.
-spec update(egraph_callback:id(), egraph_k(), integer(), state()) ->
    {boolean(), state()}.
update(Key, V, _QsProplist, State) ->
    update(Key, V, State).

%% @doc Delete an existing resource.
-spec delete(egraph_callback:id(), state()) -> {boolean(), state()}.
delete(_Key, State) ->
    {false, State}.

%%%===================================================================
%%% Internal
%%%===================================================================

create_or_update_info(Info, State) ->
    #{ <<"name">> := Key,
       <<"arguments">> := Arguments
     } = Info,
    true = is_binary(Key),
    true = is_list(Arguments),

    Arity = length(Arguments),
    try
        %% TODO: Optimize and do not query database always
        Fun = case egraph_function_model:read_resource(Key, Arity) of
            {ok, [Val]} ->
                Details = maps:get(<<"details">>, Val),
                DbHash = maps:get(<<"details_hash">>, Val),
                %% Note that the hash is a hex binary and not pure binary
                case egraph_cache_util:get({func, Key, Arity}, ?CACHE_GENERIC) of
                    {ok, {CachedFun, Hash}} ->
                        case DbHash of
                            Hash ->
                                CachedFun;
                            _ ->
                                 F = egraph_compiler:evaluate_erlang_expression(Details, normal),
                                 egraph_cache_util:async_put({func, Key, Arity},
                                                            {F, DbHash},
                                                            ?CACHE_GENERIC),
                                F
                        end;
                    _ ->
                        F = egraph_compiler:evaluate_erlang_expression(Details, normal),
                        egraph_cache_util:async_put({func, Key, Arity},
                                                    {F, DbHash},
                                                    ?CACHE_GENERIC),
                        F
                  end;
              _ ->
                  case egraph_cache_util:get({func, Key, Arity}, ?CACHE_GENERIC) of
                     {ok, {CachedFun, _Hash}} ->
                         CachedFun;
                      _ ->
                          undefined
                  end
          end,
          case is_function(Fun) of
              true ->
                  {arity, FunArity} = erlang:fun_info(Fun, arity),
                  FunArity = Arity,  %% validate arity
                  Output = erlang:apply(Fun, Arguments),
                  lager:debug("Output = ~p", [Output]),
                  {#{<<"status">> => <<"success">>, <<"result">> => Output}, State};
              false ->
                  {false, State}
          end
    catch
        ExceptionClass:ExceptionError:StackTrace ->
            lager:error("[Exception]: ~p:~p:~p", [ExceptionClass, ExceptionError, StackTrace]),
            {#{<<"status">> => <<"error">>,
               <<"exception">> => #{
                   <<"class">> => egraph_util:convert_to_binary(ExceptionClass),
                   <<"error">> => egraph_util:convert_to_binary(ExceptionError),
                   <<"stacktrace">> => list_to_binary(io_lib:format("~p", [StackTrace]))
                  }}, State}
            %%{false, State}
    end.

