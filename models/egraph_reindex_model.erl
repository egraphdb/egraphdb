%%%-------------------------------------------------------------------
%%% @author neerajsharma
%%% @copyright (C) 2018, Neeraj Sharma
%%% @doc
%%%
%%% @end
%%% %CopyrightBegin%
%%%
%%% Copyright Neeraj Sharma <neeraj.sharma@alumni.iitg.ernet.in> 2017.
%%% All Rights Reserved.
%%%
%%% Licensed under the Apache License, Version 2.0 (the "License");
%%% you may not use this file except in compliance with the License.
%%% You may obtain a copy of the License at
%%%
%%%     http://www.apache.org/licenses/LICENSE-2.0
%%%
%%% Unless required by applicable law or agreed to in writing, software
%%% distributed under the License is distributed on an "AS IS" BASIS,
%%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%%% See the License for the specific language governing permissions and
%%% limitations under the License.
%%%
%%% %CopyrightEnd%
%%%-------------------------------------------------------------------
-module(egraph_reindex_model).
%% -behaviour(egraph_callback).
-export([init/0, init/2, terminate/1, % CRUD
         validate/2, create/3, read/2, update/3, delete/2]).
-export([create/4, update/4]).
-export([read_all_resource/3]).
-export([delete_resource/1]).
-export([read_resource/1]).
-export_type([egraph_k/0]).

-include("egraph_constants.hrl").

-type egraph_k() :: map().
-type state() :: term().

-define(LAGER_ATTRS, [{type, model}]).

%%%===================================================================
%%% API
%%%===================================================================

%%%===================================================================
%%% Callbacks
%%%===================================================================

%% @doc Initialize the state that the handler will carry for
%% a specific request throughout its progression. The state
%% is then passed on to each subsequent call to this model.
-spec init() -> state().
init() ->
    nostate.

init(_, QsProplist) ->
    [{proplist, QsProplist}].

%% @doc At the end of a request, the state is passed back in
%% to allow for clean up.
-spec terminate(state()) -> term().
terminate(_State) ->
    ok.

%% @doc Return, via a boolean value, whether the user-submitted
%% data structure is considered to be valid by this model's standard.
-spec validate(egraph_k() | term(), state()) -> {boolean(), state()}.
validate(V, State) ->
    {is_map(V) orelse is_list(V) orelse is_boolean(V), State}.

%% @doc Create a new entry. If the id is `undefined', the user
%% has not submitted an id under which to store the resource:
%% the id needs to be generated by the model, and (if successful),
%% returned via `{true, GeneratedId}'.
%% Otherwise, a given id will be passed, and a simple `true' or
%% `false' value may be returned to confirm the results.
%%
%% The created resource is validated before this function is called.
-spec create(egraph_callback:id() | undefined, egraph_k(), state()) ->
        {false | true | {true, egraph_callback:id()}, state()}.
create(undefined, V, State) ->
    create_or_update_info(V, State);
create(Key, V, State) ->
    Info2 = V#{<<"shard_id">> => egraph_util:convert_to_integer(Key)},
    create_or_update_info(Info2, State).

%% @doc Create a new entry along with an expiry of some seconds.
-spec create(egraph_callback:id() | undefined, egraph_k(),
             [{binary(), binary()}], state()) ->
    {false | true | {true, egraph_callback:id()}, state()}.
create(Key, V, _QsProplist, State) ->
    create(Key, V, State).

%% @doc Read a given entry from the store based on its Key.
-spec read(egraph_callback:id(), state()) ->
        { {ok, egraph_k()} |
          {function, Fun :: function()},
          {error, not_found}, state()}.
read(undefined, State) ->
    %% return everthing you have
    {{function, fun read_all_resource/3}, State};
read(Key, State) ->
    case read_resource(Key) of
        {ok, Vals} ->
            {{ok, Vals}, State};
        R ->
            {R, State}
    end.

%% @doc Update an existing resource.
%%
%% The modified resource is validated before this function is called.
-spec update(egraph_callback:id(), egraph_k(), state()) -> {boolean(), state()}.
update(Key, V, State) ->
    Info2 = V#{<<"shard_id">> => egraph_util:convert_to_integer(Key)},
    create_or_update_info(Info2, State).

%% @doc Update an existing resource with some expiry seconds.
-spec update(egraph_callback:id(), egraph_k(), integer(), state()) ->
    {boolean(), state()}.
update(Key, V, _QsProplist, State) ->
    update(Key, V, State).

%% @doc Delete an existing resource.
-spec delete(egraph_callback:id(), state()) -> {boolean(), state()}.
delete(Key, State) ->
    {delete_resource(Key), State}.

%%%===================================================================
%%% Internal
%%%===================================================================

create_or_update_info(Info, State) ->
    #{ <<"shard_id">> := Key } = Info,
    true = is_integer(Key),

    TimeoutMsec = ?DEFAULT_MYSQL_TIMEOUT_MSEC,
    TableName = ?EGRAPH_TABLE_REINDEX_STATUS,
    ReturnLoc = egraph_util:convert_to_binary(Key),
    case read_resource(Key) of
        {error, not_found} ->
            case sql_insert_record(TableName, Info, TimeoutMsec) of
                true ->
                    {{true, ReturnLoc}, State};
                false ->
                    {false, State}
            end;
        {ok, [DbInfo]} ->
            OldVersion = maps:get(<<"version">>, DbInfo),
            %% TODO: Check for failures while updating info
            sql_update_record(TableName, OldVersion, Info, TimeoutMsec),
            {{true, ReturnLoc}, State}
    end.

%% TODO: Find the cluster nodes which must have this data and delete from there.
delete_resource(Key) ->
    TableName = ?EGRAPH_TABLE_REINDEX_STATUS,
    Q = iolist_to_binary([<<"DELETE FROM ">>,
                          TableName,
                          <<" WHERE shard_id=?">>]),
    Params = [Key],
    TimeoutMsec = ?DEFAULT_MYSQL_TIMEOUT_MSEC,
    case egraph_sql_util:mysql_write_query(
           ?EGRAPH_RW_MYSQL_POOL_NAME,
           Q, Params, TimeoutMsec) of
        ok ->
            true;
        _ ->
            false
    end.

%% TODO: Find the cluster nodes which must have this data and pull from there.
-spec read_resource(binary()) -> {ok, [map()]} | {error, term()}.
read_resource(Key) ->
    TableName = ?EGRAPH_TABLE_REINDEX_STATUS,
    Q = iolist_to_binary([<<"SELECT * FROM ">>,
                          TableName,
                          <<" WHERE shard_id=?">>]),
    Params = [Key],
    read_generic_resource(Q, Params).

-spec read_all_resource(ShardKey :: integer(),
                        Limit :: integer(),
                        Offset :: integer()) ->
    {ok, [map()], NewOffset :: integer()} | {error, term()}.
read_all_resource(_, Limit, Offset) ->
    TableName = ?EGRAPH_TABLE_REINDEX_STATUS,
    %% do reverse order so that when transform_result is invoked with
    %% lists:foldl/3, so the order goes back to ascending order.
    Q = iolist_to_binary([<<"SELECT * FROM ">>,
                          TableName,
                          <<" ORDER BY shard_id DESC LIMIT ? OFFSET ?">>]),
    Params = [Limit, Offset],
    case read_generic_resource(Q, Params) of
        {ok, R} ->
            {ok, R, Offset + length(R)};
        E ->
            E
    end.

read_generic_resource(Query, Params) ->
    ConvertToMap = true,
    TimeoutMsec = ?DEFAULT_MYSQL_TIMEOUT_MSEC,
    case egraph_sql_util:mysql_query(
           [?EGRAPH_RO_MYSQL_POOL_NAME],
           Query, Params, TimeoutMsec, ConvertToMap) of
        {ok, Maps} ->
            Maps2 = lists:foldl(fun transform_result/2, [], Maps),
            {ok, Maps2};
        Error ->
            Error
    end.

transform_result(E, AccIn) ->
    R = maps:fold(fun(K, {{_, _, _}, {_, _, _}} = V, AccIn2) ->
                      [{K, qdate:to_string(<<"Y-m-d H:i:s">>, V)} | AccIn2];
                 (<<"details">> = K, V, AccIn2) ->
                      [{K, decode_data(V)} | AccIn2];
                 (K, V, AccIn2) ->
                      [{K, V} | AccIn2]
              end, [], E),
    E2 = maps:from_list(R),
    [E2 | AccIn].

sql_insert_record(TableName, Info, TimeoutMsec) ->
    #{ <<"shard_id">> := Key,
       <<"is_reindexing">> := IsReindexing,
       <<"details">> := Details
     } = Info,

    DefaultVersion = 0,
    UpdatedDateTime = qdate:to_date(erlang:system_time(second)),
    Q = iolist_to_binary([<<"INSERT INTO ">>,
                          TableName,
                          <<" VALUES(?, ?, ?, ?, ?)">>]),
    Params = [Key,
              IsReindexing,
              encode_data(Details),
              DefaultVersion,
              UpdatedDateTime],
    %% TODO: find out the cluster nodes which must persist this data
    %%       and save it there.
    case egraph_sql_util:mysql_write_query(
           ?EGRAPH_RW_MYSQL_POOL_NAME,
           Q, Params, TimeoutMsec) of
        ok ->
            true;
        _ ->
            false
    end.

sql_update_record(TableName, OldVersion, Info, TimeoutMsec) ->
    #{ <<"shard_id">> := Key,
       <<"is_reindexing">> := IsReindexing,
       <<"details">> := Details
     } = Info,
    Version = OldVersion + 1,
    UpdatedDateTime = qdate:to_date(erlang:system_time(second)),
    Q = iolist_to_binary([<<"UPDATE ">>,
                          TableName,
                          <<" SET version=?, is_reindexing=?,">>,
                          <<" details=?, updated_datetime=? WHERE shard_id=? and version=?">>]),
    Params = [Version,
              IsReindexing,
              encode_data(Details),
              UpdatedDateTime,
              Key,
              OldVersion],
    %% TODO: need to check whether update indeed happened or not because
    %% the where clause may not match.
    case egraph_sql_util:mysql_write_query(
           ?EGRAPH_RW_MYSQL_POOL_NAME,
           Q, Params, TimeoutMsec) of
        ok -> true;
        _ -> false
    end.

encode_data(Term) ->
    erlang:term_to_binary(Term).

decode_data(Data) ->
    erlang:binary_to_term(Data).


